\section{Formal results}
\label{sec:formal-results}

%\begin{itemize}
%	\item Results that we rely on (petri nets, semilinear sets)
%	\item The base algorithm described in math (without any optimizations)
%	\item Time complexity
%	\item proof for correctness of bidirectional pruning
%	\item mathematical description of optimizations
%\end{itemize}


\subsection{Background}

\paragraph{Petri nets.}
A \emph{Petri net} is a tuple
\[
N = (P, T, \mathsf{pre}, \mathsf{post}, M_0),
\]
where \(P\) is a finite set of \emph{places}, \(T\) a finite set of \emph{transitions},
\(\mathsf{pre},\mathsf{post}:T\to\mathbb N^P\) the input/output vectors, and
\(M_0\in\mathbb N^P\) the initial marking.  A marking \(M\) is \emph{reachable} if
\[
M_0 \;\xrightarrow{\sigma}\; M
\quad\text{for some}\;\sigma\in T^*.
\]
%
A transition \(t\in T\) is \emph{enabled} at a marking \(M\in\mathbb N^P\) iff
\[
M \;\ge\; \mathsf{pre}(t)
\quad(\text{coordinate‐wise}).
\]
Firing \(t\) yields the new marking
\[
M' \;=\; M \;-\;\mathsf{pre}(t)\;+\;\mathsf{post}(t).
\]
 which represents the consumption of inputs tokens (from the input states), and the production of new ones (to the output states).
%
The \emph{reachability problem} asks, given $(N,M)$, whether $M$ is reachable from $M_0$.  Surprisingly, even in the
\emph{unbounded} setting (where places may hold arbitrarily many tokens) this problem is
decidable~\cite{Ma81,Ko82,La92}, although with
Ackermann-complete~\cite{CzWo22} complexity.
%
An example for a toy Petri Net, and both reachable and unreachable markings, appears in Appendix~\ref{appendix:toyPN}.

\paragraph{Semilinear sets and Parik’s theorem.}
A set \(S\subseteq\mathbb N^k\) is \emph{semilinear} iff
\[
S \;=\; \bigcup_{i=1}^m \Bigl\{\mathbf b_i + \sum_{j=1}^{r_i} n_j\,\mathbf p_{i,j}
\;\Big|\; n_j\in\mathbb N\Bigr\}.
\]

For $b_i, p_{i,j}\in \mathbb N^k $ being k-dimensional vectors of non-negative values.
%
Semilinear sets coincide exactly with the sets definable in \textit{Presburger arithmetic}~\cite{Pr29}.
%
By Parikh's theorem~\cite{Parikh66}, the Parikh Image of any context-free language is semilinear, and there is an effective construction mapping each word in the language to a
finite description of its Parikh Image.

\paragraph{Deciding serializability in unbounded systems.}

Finally, we build upon the theoretical findings of Bouajjani et al.~\cite{BoEmEnHa13} which prove the decidability of serializability in the unbounded case (originally referred to as a type of \textit{k-bounded-barrier linearizability}): $	\mathrm{Int}(\mathcal{N}) \;=\; \mathrm{Ser}(\mathcal{N})$.



\subsection{The Algorithm (without Optimizations)}

Let \(\mathcal S\) be the parsed Network System, with set of global states \(G\).  

\begin{enumerate}
	\item  \textbf{Serializability automaton.}  
	We define an NFA
	
\[
\mathcal A_{\mathrm{ser}}(\mathcal S)
= \bigl(Q,\Sigma,\delta,q_0,F\bigr),
\quad
Q = G
\quad\text{(the set of the NS’s global states)}
\]
\[
\Sigma
= \Bigl\{
{(\color{ForestGreen}\blacklozenge_{\mathit{req}}}\,/\,%
{\color{red}\blacklozenge_{\mathit{resp}}})
\;\Big|\;
{\color{ForestGreen}\blacklozenge_{\mathit{req}}}\in\mathit{REQ},\;
{\color{red}\blacklozenge_{\mathit{resp}}}\in\mathit{RESP}
\Bigr\}
\]
\[
\delta \;\subseteq\; Q \times \Sigma_{	{\color{ForestGreen}\blacklozenge_{\mathit{req}}}\,/\,%
	{\color{red}\blacklozenge_{\mathit{resp}}}} \times Q,
\quad
\bigl(q \xrightarrow{%
	{\color{ForestGreen}\blacklozenge_{\mathit{req}}}\,/\,%
	{\color{red}\blacklozenge_{\mathit{resp}}}%
} q'\bigr)
\;\Longleftrightarrow\;
\begin{array}{l}
	\mathcal S \text{ at global state } q
	\;\text{issues}\;
	{\color{ForestGreen}\blacklozenge_{\mathit{req}}},\\[0.5ex]
	\text{after full completion of the request, it receives}\;
	{\color{red}\blacklozenge_{\mathit{resp}}},\\[0.5ex]
	\text{arriving at global state } q'
\end{array}
\]

	
	(i.e.\ each transition is a request/response pair).  Its language
	\(L(\mathcal A_{\mathrm{ser}})\subseteq\Sigma^*\) is exactly the set of serial
	request/response traces, and we define the semilinear set of serial executions
	\[
	\mathsf{Ser}(\mathcal S)
	\;=\;
	\mathsf{Parikh}\bigl(L(\mathcal A_{\mathrm{ser}})\bigr)
	\;\subseteq\;\mathbb N^{|\Sigma|}.
	\]
	
	\item 
	\textbf{Interleaving Petri Net.}
	
	We build
	\[
	N_{\mathrm{int}}(\mathcal S)
	= (P,\,T,\,\mathsf{pre},\,\mathsf{post},\,M_0),
	\]
	where
	\[
	P
	=
	P_G \;\cup\; P_{L} \;\cup\; P_{REQ,RESP}
	\]
	
	for 
	\[
	P_G 
	= \{\,p_g \mid g\in G\}
	\quad 
	P_L 
	= \{\,p_\ell \mid \ell\in L\}
	\quad
	P_{REQ,RESP}=
	\{\,p_{{\color{ForestGreen}\blacklozenge_{\mathit{req}}}/{\color{red}\blacklozenge_{\mathit{resp}}}} \mid
	{\color{ForestGreen}\blacklozenge_{\mathit{req}}}\in \mathit{REQ}, {\color{red}\blacklozenge_{\mathit{resp}}}\in \mathit{RESP}\},
	\]
	with \(G\) the global states, \(L\) the in‐flight local states (request‐state + remaining program), and \(\mathit{RESP}\) the response labels.
	
	Transitions are partitioned as
	\[
	T = T_{\mathit{req}} \;\cup\; T_{\delta}\;\cup\;T_{\mathit{resp}},
	\]
	where
	\[
	T_{\mathit{req}} = \{\,t_{{\color{ForestGreen}\blacklozenge_{\mathit{req}}}} \mid {\color{ForestGreen}\blacklozenge_{\mathit{req}}}\in\mathit{REQ}\},\quad
	T_{\delta} = \{\,t_{(\ell,g)\to(\ell',g')} \mid (\ell,g)\xrightarrow{}(\ell',g')\in\delta_{\mathcal S}\},\quad
	T_{\mathit{resp}} = \{\,t_{{\color{red}\blacklozenge_{\mathit{resp}}}} \mid {\color{red}\blacklozenge_{\mathit{resp}}}\in\mathit{RESP}\}.
	\]
	
	Their pre/post vectors are:
	\[
	\begin{alignedat}{3}
		\mathsf{pre}\bigl(t_{{\color{ForestGreen}\blacklozenge_{\mathit{req}}}}\bigr)
		&= \mathbf0, &
		\mathsf{post}\bigl(t_{{\color{ForestGreen}\blacklozenge_{\mathit{req}}}}\bigr)
		&= \mathbf1_{p_{\ell_r}}, 
		&&\text{for each }{\color{ForestGreen}\blacklozenge_{\mathit{req}}}\in\mathit{REQ},\\
		\mathsf{pre}\bigl(t_{(\ell,g)\to(\ell',g')}\bigr)
		&= \mathbf1_{p_\ell} + \mathbf1_{p_g}, &
		\mathsf{post}\bigl(t_{(\ell,g)\to(\ell',g')}\bigr)
		&= \mathbf1_{p_{\ell'}} + \mathbf1_{p_{g'}}, 
		&&\text{for each }(\ell,g)\!\to\!(\ell',g')\in\delta_{\mathcal S},\\
		\mathsf{pre}\bigl(t_{{\color{red}\blacklozenge_{\mathit{resp}}}}\bigr)
		&= \mathbf1_{p_\ell}, &
		\mathsf{post}\bigl(t_{{\color{red}\blacklozenge_{\mathit{resp}}}}\bigr)
		&= \mathbf1_{p_{{\color{ForestGreen}\blacklozenge_{\mathit{req}}}/{\color{red}\blacklozenge_{\mathit{resp}}}}}, 
		&&\text{for each }{\color{red}\blacklozenge_{\mathit{resp}}}\in\mathit{RESP}\ (\ell\text{ the matching local state).}
	\end{alignedat}
	\]
	
	Finally, the initial marking is
	\[
	M_0(p_{g_0}) = 1,
	\quad
	M_0(p) = 0 \text{ for all }p\neq p_{g_0},
	\]
	where \(g_0\) is the initial global state of \(\mathcal S\).  
	
	
	
	Define the projection of all reachable marking to the places representing completed request/response pairs:
	\[
	\pi \;:\;\mathbb N^P \;\longrightarrow\;\mathbb N^{P_R}
	\quad\bigl(\pi(M)\bigr)(p_{{{\color{ForestGreen}\blacklozenge_{\mathit{req}}}/{\color{red}\blacklozenge_{\mathit{resp}}}}})\;=\;M(p_{{{\color{ForestGreen}\blacklozenge_{\mathit{req}}}/{\color{red}\blacklozenge_{\mathit{resp}}}}})\text{ for }p_{{{\color{ForestGreen}\blacklozenge_{\mathit{req}}}/{\color{red}\blacklozenge_{\mathit{resp}}}}}\in P_{REQ,RESP}.
	\]
	Then the multiset of all  (${{\color{ForestGreen}\blacklozenge_{\mathit{req}}}/{\color{red}\blacklozenge_{\mathit{resp}}}}$) pairs of the NS, attained by any interleaving, is:
	\[
	\mathsf{Int}(\mathcal S)
	\;=\;
	\bigl\{\;\pi(M)\;\bigm|\;M_0 \xrightarrow{*} M\text{ in }N_{\mathrm{int}}(\mathcal S)\bigr\}.
	\]
	
	\item \textbf{Non-serializable set.}  
	Let
	\(\;\mathsf{NonSer}(\mathcal S)=\mathbb N^{|\Sigma|}\setminus \mathsf{Ser}(\mathcal S)\), i.e., all (${{\color{ForestGreen}\blacklozenge_{\mathit{req}}}/{\color{red}\blacklozenge_{\mathit{resp}}}}$) pairs that \textit{cannot} be attained via a serializable execution.
	
	\item \textbf{Reachability encoding.}  
	Ask whether there exists a marking \(M\) of \(N_{\mathrm{int}}(\mathcal S)\) such that
	\[
	M_0 \xrightarrow{*} M
	\quad\wedge\quad
	\pi(M)\in \mathsf{NonSer}(\mathcal S).
	\]
	
	\item \textbf{Decision.}  
	\begin{itemize}
		\item \sat: yields a counterexample interleaving \(M\) with
		\(\pi(M)\notin \mathsf{Ser}(\mathcal S)\).
		\item \unsat: yields an inductive (unbounded) invariant of
		\(N_{\mathrm{int}}\), which back-translates to a proof of
		serializability for \(\mathcal S\).
	\end{itemize}



\item \textbf{Validation.}  
	\begin{itemize}
	\item if \sat we validate the reachable trace and project it to the NS semantics to represent a valid interleaving that results into request/response pairs which cannot be attained in serial executions.
	See example in subsec.~\ref{subsec:ns-not-serializable}.
	
	\item if \unsat:
	we generate an inductive invariant over the interleaving Petri Net, which proves the semilinear set cannot be attained via an interleaving.
	See example in subsec.~\ref{subsec:ns-serializable}.
\end{itemize}
\end{enumerate}


%\guy{should we add/prove the following?}
%
%\begin{proposition}
%	Let $N_{\mathrm{int}}(\mathcal S)=(P,T,\mathsf{pre},\mathsf{post},M_0)$ be the interleaving Petri net constructed above, and let
%	\[
%	\pi\colon\mathbb N^P\to\mathbb N^{P_R}
%	\]
%	be the projection onto the request/response places $P_R$.  Then
%	\[
%	\mathsf{Int}(\mathcal S)
%	\;=\;
%	\{\;\pi(M)\;\mid\;M_0\xrightarrow{*}M\}.
%	\]
%\end{proposition}


\subsection{Example: Non Serializable Program}
\label{subsec:ns-not-serializable}

\paragraph{Serializable NFA Extraction.}

Continuing the running (non-serializable) example presented in Listing~\ref{lst:MotivatingExample2NonSer}, the NS presented in Fig.~\ref{fig:code2ExampleNS} allows us to also extract the NFA encoding all serial executions. The states encode the global variable values, and the edges encode request/response pairs for all serial executions. As can be seen, serial executions can produce only pairs of the type ({\color{ForestGreen}$\blacklozenge_\text{main}$/{\color{red}$\blacklozenge_1$}}), while maintaining the only reachable global state $[X=0]$:

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.5\textwidth,trim=0 0 0 0,clip]{plots/code_2_NFA.png}
	\caption{NFA for serialized executions of Listing~\ref{lst:MotivatingExample2NonSer} program.}
	\label{fig:code2ExampleNFA}
\end{figure}

\paragraph{Petri Net Extraction.}

Finally, the NS gives rise to to generate the following Petri Net, encoding all possible interleavings of our program:

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.7\textwidth]{plots/code_2_PN_with_annotation.png}
	\caption{Petri Net for interleaving executions of Listing~\ref{lst:MotivatingExample2NonSer} program. Note that there doesn't exist any valid firing sequence that can reach place $P_8$, representing a response of {\color{red}$\blacklozenge_0$}.}
	\label{fig:code2ExamplePN}
\end{figure}

The places represent the $\delta$ transitions of our NS --- encoding either a ``step'' of our program, or spawning a request ($t_1$, which  corresponds to spawning request {\color{ForestGreen}$\blacklozenge_\text{main}$}), or returning a response, e.g. transitions $t_6,t_7$ that corresponds to outputting responses {\color{red}$\blacklozenge_1$},{\color{red}$\blacklozenge_0$}.
%
Some places (\textcolor{blue}{$P_2$},\textcolor{blue}{$P_3$}) corresponds to the global state, while others ($P_1,P_4,P_5,P_6$) corresponds to the local state of an in-flight request.
%
Each token corresponds to a single request packet, or (in the case of the global-variable-encoding places), to the global state of the program.

\paragraph{Counterexample Extraction.}

Regarding the aforementioned program, we automatically generate the following reachability query for the Petri net of Figure~\ref{fig:code1ExamplePN} (which, if satisfiable, indicates the program is not serializable):

\guy{Nicolas could you fix the "exists Marking M"? How do you suggest we formulize?}

\[
\exists\,M.\; 
P_1 = 0 \wedge 
\textcolor{blue}{P_2} \ge 0 \wedge \textcolor{blue}{P_3} \ge 0  \wedge P_4 = 0
\wedge P_5 = 0 \wedge P_6 = 0 \wedge \textcolor{red}{P_7} = 0 \wedge \textcolor{red}{P_8} \ge 1.
\]
This asserts the existence of a marking with no tokens on $P_1,P_4,P_5,P_6$,$\textcolor{red}{P_7}$, at least one token on $\textcolor{red}{P_8}$, and arbitrary tokens on $\textcolor{blue}{P_2},\textcolor{blue}{P_3}$.  In fact, the target marking
\[
M^* = \{\textcolor{blue}{P_3}(1),\;\textcolor{red}{P_7}(1),\;\textcolor{red}{P_8}(1)\}
\]
is reachable.  Table~\ref{tab:PetriNetFiringCounterexample} lists a firing sequence that leads to $M^*$.





\begin{table}[H]
	\centering
	\label{tab:reach-seq}
	\begin{tabular}{c l c c c c c c}
		\toprule
		\textbf{Step} 
		& \textbf{Firing} 
		& \multicolumn{3}{c}{\textbf{Marking (after firing)}} 
		& \multicolumn{3}{c}{\textbf{Description (after firing)}} \\
		\cmidrule(lr){3-5} \cmidrule(lr){6-8}
		& 
		& \textbf{Global} 
		& \textbf{Local} 
		& \textbf{Responses} 
		& \textbf{Global state} 
		& \textbf{In-flight packets} 
		& \textbf{Responses} \\
		\midrule
		0 & --                                  
		& {\color{blue}$P_3$(1)}                  
		& --                                    
		& --                                    
		& {\color{blue}[X=0]}                   
		& --                          
		& --                                    \\
		1 & $t_1$ 
		& {\color{blue}$P_3$(1)}                  
		& $P_1$(1)                                
		& --                                    
		& {\color{blue}[X=0]}                   
		& {\color{ForestGreen}$\blacklozenge_\text{main}$} 
		& --                                    \\
		2 & $t_1$ 
		& {\color{blue}$P_3$(1)}                  
		& $P_1$(2)                                
		& --                                    
		& {\color{blue}[X=0]}                   
		& {\color{ForestGreen}$\blacklozenge_\text{main}$}, {\color{ForestGreen}$\blacklozenge_\text{main}$}  
		& --                                    \\
		3 & $t_3$                                  
		& {\color{blue}$P_2$(1)}                  
		& $P_1$(1),$P_4$(1)                          
		& --                                   
		&                                    {\color{blue}[X=1]}    
		&                                    {\color{black}$\blacklozenge_\text{until yield}$}, {\color{ForestGreen}$\blacklozenge_\text{main}$}   
		& --                                    \\
		4 & $t_2$                                  
		& {\color{blue}$P_2$(1)}                  
		& $P_4$(2)                                
		& --                                    
		&                                    {\color{blue}[X=1]}    
		&                                    {\color{black}$\blacklozenge_\text{until yield}$}, {\color{black}$\blacklozenge_\text{until yield}$}   
		& --                                    \\
		5 & $t_4$                                  
		& {\color{blue}$P_3$(1)}                  
		& $P_5$(1),$P_4$(1)                          
		& --                                    
		&                                   {\color{blue}[X=0]}     
		&                                    {\color{black}$\blacklozenge_\text{after yield}$}, {\color{black}$\blacklozenge_\text{until yield}$}   
		& --                                    \\
		6 & $t_6$                     
		& {\color{blue}$P_3$(1)}                  
		& $P_4$(1)                                
		& {\color{red}$P_7$(1)}                    
		&                                      	{\color{blue}[X=0]}  
		&                                    {\color{black}$\blacklozenge_\text{until yield}$}   
		&                                   {\color{red}$\blacklozenge_1$}     \\
		7 & $t_5$                                  
		& {\color{blue}$P_3$(1)}                  
		& $P_6$(1)                                
		& {\color{red}$P_7$(1)}                    
		&                                   {\color{blue}[X=0]}    
		&                                    {\color{black}$\blacklozenge_\text{after yield}$}      
		&                                   {\color{red}$\blacklozenge_1$}        \\
		8 & $t_7$                     
		& {\color{blue}$P_3$(1)}                                  
		& --                                    
		& {\color{red}$P_7$(1),\color{red}$P_8$(1)}    
		&                                   {\color{blue}[X=0]}    
		&                                   --    
		&                                   {\color{red}$\blacklozenge_0$}, {\color{red}$\blacklozenge_1$}       \\
		\bottomrule
	\end{tabular}
	\caption{Firing sequence reaching the target marking $M^*$. The marking $P_i(n_j)$ indicates that there are $n_j$ tokens on place $P_i$. The initial marking has a single token in place $P_3$ encoding the initial global state.}
	\label{tab:PetriNetFiringCounterexample}
\end{table}

%\newpage

\subsection{Example: Serializable Program}
\label{subsec:ns-serializable}

Now, we observe again the adjusted program with locks (as previously described in Listing~\ref{lst:MotivatingExample3Ser}).
%
Due to space limitations, we relegate figures of the corresponding Network System, Serailizability NFA, and Interleaving Petri Net to Appendix~\ref{appendix:MoreNsExamples}, and focus on the serializability proof certificate.

Non-serializability corresponds to the Petri Net (in Fig.~\ref{fig:code3ExamplePN}) being able to reach the following marking:

\[
\exists\,M.\; \textcolor{blue}
P_1 = 0 \wedge 
{P_2} \ge 0 \wedge \textcolor{blue}{P_3} \ge 0  \wedge P_4 = 0
\wedge P_5 = 0 \wedge P_6 = 0 \wedge \textcolor{red}{P_7} = 0 \wedge \textcolor{red}{P_8} \ge 1.
\]


Note that this happened to be the exact same property as encoding non-serializability in the previous example, however, the Petri Net places $(P_1,\ldots,P_8)$ encode different states that correspond to the updated program. For example, now each place in the PN that encodes a global state accounts for two global variables, $X$ and $L$. 
%
Furthermore, unlike the previous example, this semilinear encoding (of non serializability) is \textit{unreachable}, as witness by the following inductive invariant that we produce.


\[
\begin{aligned}
	&(P_{1},\textcolor{blue}{P_{2}},\textcolor{blue}{P_{3}},P_{4},P_{5},P_{6},\textcolor{red}{P_{7}},\textcolor{red}{P_{8}})
	\;\mapsto\;\\
	&\quad
	\exists\,e_{0},\dots,e_{5}\ge0.\;
	\Bigl(
	e_{2}-e_{1}+\textcolor{blue}{P_{3}}-1=0\;\land\;
	e_{2}+P_{1}-e_{5}=0\;\land\;
	P_{5}-e_{1}+e_{4}=0\;\land\\
	&\qquad\quad
	-\,e_{4}+\textcolor{red}{P_{7}}=0\;\land\;
	P_{6}+e_{3}-e_{0}=0\;\land\;
	\textcolor{red}{P_{8}}-e_{3}=0\;\land\\
	&\qquad\quad
	-\,e_{2}+e_{1}+e_{0}+P_{4}=0\;\land\;
	-\,e_{2}+e_{1}+\textcolor{blue}{P_{2}}=0
	\Bigr)
	\;\land\;
	\bigl(P_{4}-1\ge0\;\lor\;\textcolor{blue}{P_{3}}-1\ge0\bigr).
\end{aligned}
\]


We then revert this invariant to match our Network System, and project it to request/response pairs of the network system.
%
We get the following inductive invariants for each of the two (reachable) global states:

\begin{proof}
	
	\medskip\noindent
	For global state \textcolor{blue}{[L=0,X=0]}
	the projected invariant is:
	\[
	\bigl(\,\text{\color{ForestGreen}$\blacklozenge_{\text{main}}$}/\text{\color{red}$\blacklozenge_{0}$},\;
	\text{\color{ForestGreen}$\blacklozenge_{\text{main}}$}/\text{\color{red}$\blacklozenge_{1}$}\bigr)
	\;\mapsto\;
	\exists\,e_{0},\dots,e_{5}\ge0.\;
	\begin{aligned}[t]
		& e_{2}-e_{1}=0,\quad
		e_{2}-e_{5}=0,\quad
		-e_{1}+e_{4}=0,\\
		& -e_{4}+\bigl(\text{\color{ForestGreen}$\blacklozenge_{\text{main}}$}/\text{\color{red}$\blacklozenge_{1}$}\bigr)=0,\quad
		-e_{0}+e_{3}=0,\quad
		-e_{3}+\bigl(\text{\color{ForestGreen}$\blacklozenge_{\text{main}}$}/\text{\color{red}$\blacklozenge_{0}$}\bigr)=0,\\
		& -e_{2}+e_{1}+e_{0}=0,\quad
		-e_{2}+e_{1}=0.
	\end{aligned}
	\]
	From these:
	\[
	e_{1}=e_{2}=e_{4}=e_{5}=(\;
	\text{\color{ForestGreen}$\blacklozenge_{\text{main}}$}/\text{\color{red}$\blacklozenge_{1}$}),\;
	e_{0}=e_{3}=
	(\text{\color{ForestGreen}$\blacklozenge_{\text{main}}$}/\text{\color{red}$\blacklozenge_{0}$}),
	\]
	and
	\[
	-e_{2}+e_{1}+e_{0}=0\;\Longrightarrow\;e_{0}=0.
	\]
	Thus
	\[
	(	\text{\color{ForestGreen}$\blacklozenge_{\text{main}}$}/\text{\color{red}$\blacklozenge_{0}$})
	=0,
	\]
	indicating that  (\(\text{\color{ForestGreen}$\blacklozenge_{\text{main}}$}/\text{\color{red}$\blacklozenge_{0}$}\)) cannot be attained from the global state
	\textcolor{blue}{[L=0,X=0]}.
	
	\medskip\noindent
	In the second case, for the global state \textcolor{blue}{[L=1,X=1]}.
	The projected invariant is:
	
	
	\[
	\bigl(\,\text{\color{ForestGreen}$\blacklozenge_{\text{main}}$}/\text{\color{red}$\blacklozenge_{0}$},\;
	\text{\color{ForestGreen}$\blacklozenge_{\text{main}}$}/\text{\color{red}$\blacklozenge_{1}$}\bigr)
	\;\mapsto\;
	\exists\,e_{0},\dots,e_{5}.\;\bot,
	\]
	which is unsatisfiable.  Hence, no completed‐request pair, and in particular no (\(\text{\color{ForestGreen}$\blacklozenge_{\text{main}}$}/\text{\color{red}$\blacklozenge_{0}$}\)) pair can be produced from this state.
	\guy{Jules is this part correct?}
	
	\medskip\noindent
	\textbf{Conclusion.}
	In all reachable states
	it holds that there cannot be any request/response pair of type
	(	$	\text{\color{ForestGreen}$\blacklozenge_{\text{main}}$}/\text{\color{red}$\blacklozenge_{0}$}
	$).
	%
	Furthermore, this indicates that the only attainable request/response pairs are of the form 	($	\text{\color{ForestGreen}$\blacklozenge_{\text{main}}$}/\text{\color{red}$\blacklozenge_{1}$})
	$, which are included in the language of of NFA for serial executions. Thus, this program is serializable.
	%
	We further show (in Appendix~\ref{appendix:InductiveInvariantExample}) that these invariants are \textit{inductive}: they encompass the system’s initial state and, once satisfied, remain true for all subsequent executions.
\end{proof}



%\newpage


\subsection{Time/Space Complexity}

\todo{consult with Jules}


\subsection{Optimizations}
\label{sec:optimizations}

\todo{check}

We apply four optimizations to the base algorithm to control intermediate blow‐up in the size of both the PN and the constructed semilinear set.

\paragraph{(1) Bidirectional pruning.}  
\guy{should we reformulate this like in Appendix C?}
Let \(N=(P,T,\mathsf{pre},\mathsf{post},M_0)\) and let \(\mathit{Tgt}\subseteq P\) be the “nonzero” places extracted from the Presburger constraints.  Define the flip of \(N\), \(\overline N\), by swapping \(\mathsf{pre}\) and \(\mathsf{post}\).  We compute a decreasing sequence of transition‐sets
\[
T^{(0)} = T,\qquad
\begin{aligned}
	R_{\mathrm{fw}}^{(k)} &= \{\,t\in T^{(k)} \mid \exists\,M_0\xrightarrow{*}M\text{ in }N\text{ enabling }t\},\\
	R_{\mathrm{bw}}^{(k)} &= \{\,t\in T^{(k)} \mid \exists\,M\xrightarrow{*}M'\text{ in }\overline N\text{ with }M'(p)>0\;(p\in\mathit{Tgt})\},\\
	T^{(k+1)} &= R_{\mathrm{fw}}^{(k)} \;\cap\; R_{\mathrm{bw}}^{(k)}.
\end{aligned}
\]
We repeat until \(T^{(k+1)}=T^{(k)}\).  In each iteration we record
\(\Delta_{\mathrm{fw}}^{(k)}=R_{\mathrm{fw}}^{(k-1)}\setminus R_{\mathrm{fw}}^{(k)}\)
and
\(\Delta_{\mathrm{bw}}^{(k)}=R_{\mathrm{bw}}^{(k-1)}\setminus R_{\mathrm{bw}}^{(k)}\).
%
This optimization allows to significantly prune the Petri Net while still over-approximating all reachable markings (see the proof in Appendix~\ref{appendix:BidirectionalProof}).

\paragraph{(2) Semilinear‐set pruning.}  
Recall a semilinear set is \(S=\bigcup_{i=1}^m L_i\) with
\(\displaystyle L_i=\{\,b_i+\sum_{p\in P_i}n_p\,p\mid n_p\in\mathbb N\}\).  
%
We replace each period‐basis \(P_i\) by
\[
P_i \;:=\;\{\,p\in P_i \mid p\notin\mathsf{Span}(P_i\setminus\{p\})\},
\]
dropping any ``redundant” period, and remove any \(L_j\subseteq L_i\) for \(i\neq j\), iterating to a fixpoint so no two components subsume one another.

\paragraph{(3) Generating fewer constraints.}  
Let $\mathrm{comp}(S)=\{L_1,\dots,L_m\}$ 
be the multiset of linear components of the semilinear set 
\(\displaystyle S=\bigcup_{i=1}^m L_i\), where each 
\(\;L_i=b_i+\langle P_i\rangle\) with \(b_i\in\mathbb N^d\) and 
\(P_i\subseteq\mathbb N^d\).  Define the pruning operator
\[
\mathrm{new}(\mathcal C)
\;=\;
\bigcup\bigl\{\,L\in\mathcal C \;\bigm|\;\nexists\,L'\in\mathcal C\setminus\{L\}:\;L'\subsetneq L\bigr\},
\]
which removes any component strictly containing another.  
%
\guy{Nicolas is it clear we mean that we fix their semilinear "meaning" of the regex operations? For example, + is union etc..}
Then, we replace the naïve semilinear‐set operations by
\[
S\;+\;T
\;=\;
\mathrm{new}\bigl(\mathrm{comp}(S)\,\cup\,\mathrm{comp}(T)\bigr),
\]
\[
S\;\cdot\;T
\;=\;
\mathrm{new}\Bigl(\{\,L_i\cdot L'_j \mid L_i\in\mathrm{comp}(S),\;L'_j\in\mathrm{comp}(T)\}\Bigr),
\]
where for
\(\;L_i=b_i+\langle P_i\rangle,\;L'_j=b'_j+\langle P'_j\rangle\) we set
$
L_i\cdot L'_j
=\;(b_i+b'_j)\;+\;\langle\,P_i\cup P'_j\,\rangle.
$
Finally, for Kleene‐star and plus on the regex side one similarly applies
\(\mathrm{new}(\cdot)\) to the collection of ``folded” components instead of
building all intermediate ones:
\[
S^*
=\mathrm{new}\Bigl(\bigcup_{k\ge0}\bigl(\mathrm{comp}(S)\bigr)^k\Bigr),
\qquad
S^+
=S\cdot S^*.
\]

\paragraph{(4) Strategic Kleene elimination order.}  
When converting an NFA \(\mathcal A=(Q,\Sigma,\delta,q_0,F)\) to a regex by repeated state‐elimination, then, instead of choosing an arbitrary state $q\in Q'$, we pick the next state
\[
q^* = 
	\arg\min_{q\in Q'}\bigl(|\delta_{\mathrm{in}}(q)|+|\delta_{\mathrm{out}}(q)|\bigr)
\]


where \(Q'\subseteq Q\) are the states remaining to be eliminated.  This heuristic keeps the intermediate regex small.


%\newpage
