\section{Introduction}
\label{sec:introduction}

%\todo{Introduction goes here.}
%
%\todo{We motivate the problem of deciding serializability in programmable networks.}
%
%\todo{We talk about some related work if relevant.}
%
%\todo{We show that it's interesting with an example.}
%
%\todo{We describe our main results.}
%
%\todo{Important point: mention the french people here early on, so that the reviewers know that we are aware of them. Also explain clearly what is new here: a tool that can actually run and output certificates.}

%\paragraph{Contributions:}
%\begin{itemize}
%    \item Novel notion of serializability (``atomicity'' or ``semantic serializabillity'') applicable to network systems (\Cref{sec:problem-definition,sec:related:notions-of-serializability})
%    \item Decidability results (1 main theorem: \textbf{automatically proving unbounded serializability}, 2 extra theorems: ser=ser decidable, int=int undecidable) (\Cref{sec:formal-results,sec:related:deciding-serializability})
%    \item Implementation of decision procedure. Advances in semilinear sets, Petri net reachability heuristics that makes the decision procedure work. (\Cref{sec:implementation,sec:related:petri})
%    
%     \item optimizations
%     \item case study - real world problems
%     \item proof certificate checker
%\end{itemize}
%
%


In recent years, concurrent program have become highly abundant in various transactional systems. These programs allow multiple threads to run multiple programs in parallel.
Despite the various advantages afforded by concurrent programming, such programs are especially hard to reason about, due to their complex nature.
%
As such, there have been various correctness criteria put forth, with each such criteria affording a different guarantee to the user regarding eh concurrent executions in question.
One such popular criteria is \textit{serializability} which, intuitively, asks whether \textit{running parallel threads always produces an equivalent output to running them serially, one after the other}. Differently put, serializability asks whether interleaving threads will output results that are otherwise unattainable in a serial execution.
%
We note that this question in non trivial for an \textit{unbounded} number of threads. For example, observe the short snippets of code in Listings~\ref{lst:MotivatingExample1Ser},~\ref{lst:MotivatingExample2NonSer}, and ~\ref{lst:MotivatingExample3Ser}. For readability, ``requests'' can be thought of as threads; global and local variables are respectively depicted in upper-case and lower-case characters.
While the first program is clearly serializable (as there are no yields), the second one is not. For example, if one thread yields, and then another thread yields (before the previous one terminated), then one of the threads is guaranteed to return ``0'', a result that is unattainable via any serial execution. Of course, having yields does not guarantee that an execution is necessarily not serializable, as observed in the third program, which is semantically equivalent to the first one by using an additional lock variable ``L''.
These examples motivate that reasoning about serializability can be complex even for very simple programs with few threads running concurrently.
%


\noindent
\begin{minipage}[t]{0.45\textwidth}
	\begin{minipage}[t]{\textwidth}
		\begin{lstlisting}[caption={Without yield or lock (serializable)},
			label={lst:MotivatingExample1Ser}]
    request main: 
        X := 1 
        // no yield
        y := X 
        X := 0
        return y 
		\end{lstlisting}
	\end{minipage}
	\vspace{1em}
	\begin{minipage}[t]{\textwidth}
		\begin{lstlisting}[caption={With yield (not serializable)},
			label={lst:MotivatingExample2NonSer}]
    request main: 
        X := 1 
        yield 
        y := X 
        X := 0
        return y 	
		\end{lstlisting}
	\end{minipage}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.45\textwidth}
	\begin{lstlisting}[caption={With yield and lock (serializable)},
		label={lst:MotivatingExample3Ser}]
    request main: 
        // lock
        while (L == 1): 
            yield
        L := 1 

        X := 1
        yield
        y := X 
        X := 0

        // unlock    
        L := 0
        return y 
	\end{lstlisting}
\end{minipage}



Unfortunately, serializability is impossible to enforce during runtime, and hence real world systems either (i) defer to other consistency guarantees, such as the stricter notion of \textit{conflict serializability} which pertains to the read/write accesses instead of reasoning about the (harder) program semantics, and which can be enforced with two-phase locking (for additional concurrency notions see sub-sec.~\ref{subsec:related:notions-of-serializability}). Alternatively, the PL community has conducted ample research on static analysis of concurrent programs, including the analysis of serializability and its variants. However, these work suffer from various setbacks. First, they typically search for \textit{violations} of serializability, or alternatively, try to prove it while assuming strong assumptions, such as bounding the number of threads or having prior knowledge on linearization points.
Furthermore, many of these tools are tailored for specific concurrent data structures, and infeasible for an arbitrary program in a general setting.
%
There has also been extensive theoretical work, most notably, we mention the seminal work of Bouajjani et al.~\cite{BoEmEnHa13} which prove that serializability is decidable for the unbounded case (they refer to the general property as $k$-bounded linearizability).


In this work, be begin bridging these gaps, and present the first end-to-end tool to verify serializability in general programs with an arbitrary number of threads. 
As far as we are aware, this is the first decision procedure to not only identify serializability violations, but also (i) \textit{prove} that an arbitrary program is not serializable; (ii) provide an \textit{inductive proof certificate} for serializability; and (iii) demonstrate this problem on complex programs form the realm of \textit{software defined networks} (SDN).
%
Towards this end, our decision procedure builds upon the theoretical work of Bouajjani et al.~\cite{BoEmEnHa13} which presented a reduction from serializability to Petri Net reachability.  However, as Petri Net reachability is Ackermann-complete~\cite{CzWo22}, a naive translation does not suffice, rendering such a took  highly nontrivial even for basic programs. This required us to develop multiple optimizations in order to scale to complex programs. 
Our optimizations include Petri Net pruning, semilinear set compression and additional manipulations with Presburger formulas.
As we later demonstrate, these optimizations \textit{significantly} curtail the search space, allowing our solver to scale.
%
Furthermore, motivated by the timely task of SDN, 
%we formalize our decision procedure with regard to our proposed framework of \textit{network systems} (NS), which capture a wide range of programs of interest
%Furthermore, 
we also formalize serializability through the lens of \textit{networking systems} (NS) --- abstract multi-thread programs in which users send ``requests'' (corresponding to threads, or packets in SDN) and, after manipulating local and shared global variables, return responses.
Based on our theoretical NS framework, we extensively evaluated our approach on dozens of programs with a wide range of features --- including loop constructs, branching, locks, nondeterminism and more. Notably, our benchmarks also include complex programs motivating, such as stateful firewalls, BGP routing, an online shopping system, etc.
  

Building upon the previous theoretical work of deciding serializability, as well as the state-of-the-are in PN reachability solvers, we see this work as an important step in practical reasoning about concurrent programs in general, and serializability in particular.
In addition to being the first took to validate whether an arbitrary unbounded program is not serializable, we are the first to also provide a certificate thereof and to experiment on benchmarks from the timely domain of SDN.
Our tool, benchmarks and raw experimental results will all be made publicly available with the final version of this paper.

The rest of the paper is organized as follows. In Sec.~\ref{sec:tour} we present a tour of various examples motivating the complexity of deciding serializability. In Sec.~\ref{sec:problem-definition} we formally define our problem, and present our abstract  network system setting. We formalize our decision procedure and our various optimizations in Sec.~\ref{sec:formal-results}. Subsequently, we present our implementation (Sec.~\ref{sec:implementation}) and extensive evaluation (Sec.~\ref{sec:evaluation}). 
Related work is covered in Sec.~\ref{sec:related-work}, and we conclude in Sec.~\ref{sec:discussion}.


%\newpage




