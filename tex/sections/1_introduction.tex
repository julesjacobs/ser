\section{Introduction}
\label{sec:introduction}

%\todo{Introduction goes here.}
%
%\todo{We motivate the problem of deciding serializability in programmable networks.}
%
%\todo{We talk about some related work if relevant.}
%
%\todo{We show that it's interesting with an example.}
%
%\todo{We describe our main results.}
%
%\todo{Important point: mention the french people here early on, so that the reviewers know that we are aware of them. Also explain clearly what is new here: a tool that can actually run and output certificates.}

%\paragraph{Contributions:}
%\begin{itemize}
%    \item Novel notion of serializability (``atomicity'' or ``semantic serializability'') applicable to network systems (\Cref{sec:problem-definition,sec:related:notions-of-serializability})
%    \item Decidability results (1 main theorem: \textbf{automatically proving unbounded serializability}, 2 extra theorems: ser=ser decidable, int=int undecidable) (\Cref{sec:formal-results,sec:related:deciding-serializability})
%    \item Implementation of decision procedure. Advances in semilinear sets, Petri net reachability heuristics that makes the decision procedure work. (\Cref{sec:implementation,sec:related:petri})
%    
%     \item optimizations
%     \item case study - real world problems
%     \item proof certificate checker
%\end{itemize}
%
%


In recent years, concurrent systems have become highly prevalent in various transactional systems. These programs allow an arbitrary number of threads to run multiple programs in parallel.
Despite the various advantages afforded by concurrent systems, their programs are especially hard to reason about, due to their complex temporal nature.
%
As such, there have been various correctness criteria put forth, with each such criteria affording a different guarantee to the user.
One such popular criteria is \textit{serializability} which, intuitively, asks whether \textit{running parallel threads always produces an equivalent output to running them serially, one after the other}. Differently put, serializability asks whether interleaving threads could output results that are otherwise unattainable in a serial execution.
%
Although this question is trivially decidable for a bounded number of threads by enumerating all possible interleavings --- it is highly nontrivial for the \textit{unbounded} case. For example, observe the short snippets of code in Listings~\ref{lst:MotivatingExample1Ser},~\ref{lst:MotivatingExample2NonSer}, and ~\ref{lst:MotivatingExample3Ser}. For readability, ``requests'' can be thought of as threads; global and local variables are respectively depicted in upper-case and lower-case characters.
%
The first program is clearly serializable because there are no yields. In the second program however, a thread can execute X := 1 and then yield, allowing another thread to reset X to 0 before the first thread executes y := X, so that its return y yields 0. This outcome is impossible in any serial execution, since a thread running to completion would always read X as 1 before returning.
Of course, having yields does not guarantee that an execution is necessarily not serializable, as observed in the third snippet. This program uses an additional lock variable ``L'', which guarantees that even if an interleaving occurs, the program is semantically equivalent to the first one.
%
These toy examples demonstrate that reasoning about serializability can be complex even for very simple programs with few threads running concurrently.
%


\noindent
\begin{minipage}[t]{0.45\textwidth}
	\begin{minipage}[t]{\textwidth}
		\begin{lstlisting}[caption={Without yield or lock (serializable)},
			label={lst:MotivatingExample1Ser}]
    request main: 
        X := 1 
        // no yield
        y := X 
        X := 0
        return y 
		\end{lstlisting}
	\end{minipage}
	\vspace{1em}
	\begin{minipage}[t]{\textwidth}
		\begin{lstlisting}[caption={With yield (not serializable)},
			label={lst:MotivatingExample2NonSer}]
    request main: 
        X := 1 
        yield 
        y := X 
        X := 0
        return y 	
		\end{lstlisting}
	\end{minipage}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.45\textwidth}
	\begin{lstlisting}[caption={With yield and lock (serializable)},
		label={lst:MotivatingExample3Ser}]
    request main: 
        // lock
        while (L == 1): 
            yield
        L := 1 

        X := 1
        yield
        y := X 
        X := 0

        // unlock    
        L := 0
        return y 
	\end{lstlisting}
\end{minipage}



Unfortunately, serializability is impossible to enforce during runtime, and hence real world systems either (i) defer to other consistency guarantees, such as the stricter notion of \textit{conflict serializability} which pertains to the read/write accesses instead of reasoning about the (harder) program semantics (for additional concurrency notions see sub-sec.~\ref{subsec:related:notions-of-serializability}). Alternatively, the PL community has conducted ample research on static analysis of concurrent programs, including the analysis of serializability and its variants. However, these works suffer from various setbacks. First, they typically search for \textit{violations} of serializability, or alternatively, try to prove it while assuming strong assumptions, such as bounding the number of threads or having prior knowledge on linearization points.
Furthermore, many of these tools are tailored for specific concurrent data structures, and infeasible for an arbitrary program in a general setting.
%
There has also been extensive theoretical work, most notably, we mention the seminal work of Bouajjani et al.~\cite{BoEmEnHa13} which prove that serializability is decidable for the unbounded case (they refer to the general property as $k$-bounded linearizability).


In this work, be begin bridging these gaps, and present the first end-to-end tool to verify serializability in general programs with an arbitrary number of threads. 
As far as we are aware, this is the first decision procedure to not only identify serializability violations, but also (i) \textit{prove} that an arbitrary program is not serializable; (ii) provide an \textit{inductive proof certificate} for serializability; and (iii) demonstrate this problem on complex programs form the realm of \textit{software defined networks} (SDN).
%
Towards this end, our decision procedure builds upon the theoretical work of Bouajjani et al.~\cite{BoEmEnHa13} which presented a reduction from serializability to Petri Net (PN) reachability.  However, as Petri Net reachability is Ackermann-complete~\cite{CzWo22}, a naive translation does not suffice, rendering such a tool  highly nontrivial even for basic programs. To circumvent this, we developed multiple optimizations in order to scale to complex programs. 
Our optimizations include Petri Net pruning, semilinear set compression and additional manipulations with Presburger formulas.
As we later demonstrate, these optimizations \textit{significantly} curtail the search space, allowing our solver to scale.
%
Furthermore, motivated by the timely task of SDN, 
%we formalize our decision procedure with regard to our proposed framework of \textit{network systems} (NS), which capture a wide range of programs of interest
%Furthermore, 
we also formalize serializability through the lens of \textit{networking systems} (NS) --- abstract multi-thread programs in which users send ``requests'' (corresponding to threads, or packets in SDN) and, after manipulating local and shared global variables, return responses.
Based on our theoretical NS framework, we extensively evaluated our approach on dozens of programs with a wide range of features --- including loop constructs, branching, locks, nondeterminism and more. Notably, our benchmarks also include SDN-motivated programs, such as stateful firewalls, BGP routing, an online shopping system, etc.
  

Building upon the previous theoretical work of deciding serializability, as well as the state-of-the-are in PN reachability solvers, we see this work as an important step in practical reasoning about concurrent programs in general, and serializability in particular.
In addition to detecting serializability violations among unbounded programs, our tool is the first to formally prove that such programs are positively serializable, and to afford a formal certificate thereof, and to experiment on benchmarks from the timely domain of SDN.
Our tool, benchmarks and raw experimental results will all be made publicly available with the final version of this paper.

The rest of the paper is organized as follows. In Sec.~\ref{sec:tour} we present a tour of various examples motivating the complexity of deciding serializability. In Sec.~\ref{sec:problem-definition} we formally define our problem, and present our abstract  network system setting. We formalize our decision procedure and our various optimizations, as well as demonstrate them in Sec.~\ref{sec:formal-results}.. Next, we present our implementation (Sec.~\ref{sec:implementation}) and extensive evaluation (Sec.~\ref{sec:evaluation}). 
Related work is covered in Sec.~\ref{sec:related-work}, and we conclude in Sec.~\ref{sec:discussion}.


%\newpage




