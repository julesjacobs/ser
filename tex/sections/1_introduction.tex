\section{Introduction}
\label{sec:introduction}

%\todo{Introduction goes here.}
%
%\todo{We motivate the problem of deciding serializability in programmable networks.}
%
%\todo{We talk about some related work if relevant.}
%
%\todo{We show that it's interesting with an example.}
%
%\todo{We describe our main results.}
%
%\todo{Important point: mention the french people here early on, so that the reviewers know that we are aware of them. Also explain clearly what is new here: a tool that can actually run and output certificates.}

%\paragraph{Contributions:}
%\begin{itemize}
%    \item Novel notion of serializability (``atomicity'' or ``semantic serializability'') applicable to network systems (\Cref{sec:problem-definition,sec:related:notions-of-serializability})
%    \item Decidability results (1 main theorem: \textbf{automatically proving unbounded serializability}, 2 extra theorems: ser=ser decidable, int=int undecidable) (\Cref{sec:formal-results,sec:related:deciding-serializability})
%    \item Implementation of decision procedure. Advances in semilinear sets, Petri net reachability heuristics that makes the decision procedure work. (\Cref{sec:implementation,sec:related:petri})
%    
%     \item optimizations
%     \item case study - real world problems
%     \item proof certificate checker
%\end{itemize}
%
%


In recent years, concurrent programs have become highly prevalent in various transactional systems, allowing an arbitrary number of threads to run in parallel.
Despite the various advantages afforded by concurrent systems, they are especially hard to reason about, due to their complex temporal nature.
%
As such, there have been various correctness criterion put forth, with each such criteria affording a different guarantee to the user.
One such popular criteria is \textit{serializability} which, intuitively, asks whether \textit{interleaving threads always produce an equivalent output to running them serially, one after the other}. Differently put, serializability asks whether interleaving threads could output results that are otherwise unattainable in a serial execution.
%
Although this question is trivially decidable for a bounded number of threads by enumerating all possible interleavings --- it is highly nontrivial for the \textit{unbounded} case. For example, observe the short snippets of code in Listings~\ref{lst:MotivatingExample1Ser},~\ref{lst:MotivatingExample2NonSer}, and ~\ref{lst:MotivatingExample3Ser}. For readability, ``requests'' can be thought of as threads; global and local variables are respectively depicted in upper-case and lower-case characters.
%
The first program is clearly serializable because there are no yields, and hence, no interleavings. In the second program, however, a thread can execute X := 1 and then yield, allowing another thread to reset X to 0 before the first thread executes y := X, so that its returned value is 0. This outcome is impossible in any serial execution, since a thread running to completion would always read X as 1 before returning.
Of course, having yields does not guarantee that an execution is necessarily not serializable, as observed in the third snippet. This program uses an additional lock variable ``L'', which guarantees that even if an interleaving occurs, the program is semantically equivalent to the first one.
%
These toy examples demonstrate that reasoning about serializability can be complex even for very simple programs with few threads running concurrently.
%


\noindent
\begin{minipage}[t]{0.45\textwidth}
	\begin{minipage}[t]{\textwidth}
		\begin{lstlisting}[caption={Without yield or lock (serializable)},
			label={lst:MotivatingExample1Ser}]
    request main: 
        X := 1 
        // no yield
        y := X 
        X := 0
        return y 
		\end{lstlisting}
	\end{minipage}
	\vspace{1em}
	\begin{minipage}[t]{\textwidth}
		\begin{lstlisting}[caption={With yield (not serializable)},
			label={lst:MotivatingExample2NonSer}]
    request main: 
        X := 1 
        yield 
        y := X 
        X := 0
        return y 	
		\end{lstlisting}
	\end{minipage}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.45\textwidth}
	\begin{lstlisting}[caption={With yield and lock (serializable)},
		label={lst:MotivatingExample3Ser}]
    request main: 
        // lock
        while (L == 1): 
            yield
        L := 1 

        X := 1
        yield
        y := X 
        X := 0

        // unlock    
        L := 0
        return y 
	\end{lstlisting}
\end{minipage}



Unfortunately, serializability is impossible to enforce during runtime, and hence many real-world systems defer to other consistency guarantees (see sub-sec.~\ref{subsec:related:notions-of-serializability}), such as \textit{conflict serializability} which pertains to the read/write accesses instead of reasoning about the (harder) program semantics. Alternatively, the PL community has conducted ample research on static analysis of concurrent programs, including the analysis of serializability and its variants. However, these works suffer from various setbacks. First, they typically search for \textit{violations} of serializability, or alternatively, try to prove it while assuming strong assumptions, such as bounding the number of threads or having prior knowledge of linearization points.
Furthermore, many of these tools are tailored for specific concurrent data structures, and infeasible for an arbitrary program in a general setting.
%
There has also been extensive theoretical work, most notably, we mention the seminal work of Bouajjani et al.~\cite{BoEmEnHa13} which proves that serializability is decidable for the unbounded case (as a case of bounded-barrier linearizability).


In this work, we begin bridging these gaps, and present the first end-to-end tool to verify whether an arbitrary transactional program is provably serializable.  
As far as we are aware, this is the first decision procedure to not only identify serializability violations, but also (i) \textit{prove} that an arbitrary program is serializable; (ii) provide an \textit{inductive proof certificate} for serializability; and (iii) demonstrate this problem on complex programs form the realm of \textit{software defined networks} (SDN).
%
Towards this end, our decision procedure builds upon the theoretical work of Bouajjani et al.~\cite{BoEmEnHa13} which presented a reduction from serializability to Petri Net (PN) reachability.  However, as Petri Net reachability is Ackermann-complete~\cite{CzWo22}, a naive translation does not suffice, rendering such a tool highly nontrivial even for basic programs. To circumvent this, we developed multiple optimizations in order to scale to complex programs. 
Our optimizations include Petri Net pruning, semilinear set compression, and additional manipulations with Presburger formulas.
As we later demonstrate, these optimizations \textit{significantly} curtail the search space by orders of magnitude.
%
Furthermore, motivated by the timely task of SDN, 
%we formalize our decision procedure with regard to our proposed framework of \textit{network systems} (NS), which capture a wide range of programs of interest
%Furthermore, 
we also formalize serializability through the lens of \textit{networking systems} (NS) --- abstract multi-thread programs in which users send \textit{requests} (corresponding to threads, or packets) and, after manipulating local and shared global variables, return \textit{responses}.
Based on our theoretical NS framework, we extensively evaluated our approach on dozens of programs with a wide range of features --- including loop constructs, branching, locks, nondeterminism, and more. Notably, our benchmarks also include SDN-motivated programs, such as stateful firewalls, BGP routing, and an online shopping system.


Building upon the previous theoretical work of deciding serializability, as well as the state-of-the-art in PN model checking, we see this work as an important step in practical reasoning about concurrent programs in general, and about serializability in particular.
In addition to detecting serializability violations among unbounded programs, our tool is the first to formally prove that such general, unbounded programs are positively serializable, and to afford a formal certificate thereof, as well as to experiment on benchmarks from the timely domain of SDN.
Our tool, benchmarks, and experiments are available as an anonymous artifact~\cite{ArtifactRepository} and will be permanently hosted with the paperâ€™s final version.

The rest of the paper is organized as follows. In Sec.~\ref{sec:tour} we present a tour of various examples motivating the complexity of deciding serializability. In Sec.~\ref{sec:problem-definition} we formally define our framework, and present our abstract  network system setting. We formalize our decision procedure and our various optimizations, as well as demonstrate them in Sec.~\ref{sec:formal-results}. Next, we present our implementation (Sec.~\ref{sec:implementation}) and extensive evaluation (Sec.~\ref{sec:evaluation}). 
Related work is covered in Sec.~\ref{sec:related-work}, and we conclude in Sec.~\ref{sec:discussion}.
%
There is also a technical appendix accompanying this paper.

%\newpage




