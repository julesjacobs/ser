\section{Introduction}
\label{sec:introduction}

%\todo{Introduction goes here.}
%
%\todo{We motivate the problem of deciding serializability in programmable networks.}
%
%\todo{We talk about some related work if relevant.}
%
%\todo{We show that it's interesting with an example.}
%
%\todo{We describe our main results.}
%
%\todo{Important point: mention the french people here early on, so that the reviewers know that we are aware of them. Also explain clearly what is new here: a tool that can actually run and output certificates.}

%\paragraph{Contributions:}
%\begin{itemize}
%    \item Novel notion of serializability (``atomicity'' or ``semantic serializability'') applicable to network systems (\Cref{sec:problem-definition,sec:related:notions-of-serializability})
%    \item Decidability results (1 main theorem: \textbf{automatically proving unbounded serializability}, 2 extra theorems: ser=ser decidable, int=int undecidable) (\Cref{sec:formal-results,sec:related:deciding-serializability})
%    \item Implementation of decision procedure. Advances in semilinear sets, Petri net reachability heuristics that makes the decision procedure work. (\Cref{sec:implementation,sec:related:petri})
%    
%     \item optimizations
%     \item case study - real world problems
%     \item proof certificate checker
%\end{itemize}
%
%


Concurrent programs are now ubiquitous in transactional systems, where arbitrarily many threads can execute in parallel.
While concurrency offers significant performance benefits, it makes programs difficult to reason about due to complex timing interactions.
%
To address this challenge, researchers have proposed various correctness criteria, each providing different guarantees.
One popular criterion is \textit{serializability}, which asks whether \textit{interleaving threads always produce the same results as running them one after another}. In other words, serializability checks whether concurrent execution can produce results impossible in any serial execution.
%
While we can easily check serializability for a fixed number of threads by enumerating all interleavings, the problem becomes challenging for \textit{unbounded} threads. Consider the examples in Listings~\ref{lst:MotivatingExample1Ser},~\ref{lst:MotivatingExample2NonSer}, and ~\ref{lst:MotivatingExample3Ser}. Here, ``requests'' represent threads; uppercase letters denote global variables and lowercase letters denote local variables.
%
The first program is clearly serializable because there are no yields, and hence, no interleavings. In the second program, however, a thread can execute X := 1 and then yield, allowing another thread to reset X to 0 before the first thread executes y := X, so that its returned value is 0. This outcome is impossible in any serial execution, since a thread running to completion would always read X as 1 before returning.
Of course, having yields does not guarantee that an execution is necessarily not serializable, as observed in the third snippet. This program uses an additional lock variable ``L'', which guarantees that even if an interleaving occurs, the program is semantically equivalent to the first one.
%
These toy examples demonstrate that reasoning about serializability can be complex even for very simple programs with few threads running concurrently.
%


\noindent
\begin{minipage}[t]{0.45\textwidth}
	\begin{minipage}[t]{\textwidth}
		\begin{lstlisting}[caption={Without yield or lock (serializable)},
			label={lst:MotivatingExample1Ser}]
    request main: 
        X := 1 
        // no yield
        y := X 
        X := 0
        return y 
		\end{lstlisting}
	\end{minipage}
	\vspace{1em}
	\begin{minipage}[t]{\textwidth}
		\begin{lstlisting}[caption={With yield (not serializable)},
			label={lst:MotivatingExample2NonSer}]
    request main: 
        X := 1 
        yield 
        y := X 
        X := 0
        return y 	
		\end{lstlisting}
	\end{minipage}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.45\textwidth}
	\begin{lstlisting}[caption={With yield and lock (serializable)},
		label={lst:MotivatingExample3Ser}]
    request main: 
        // lock
        while (L == 1): 
            yield
        L := 1 

        X := 1
        yield
        y := X 
        X := 0

        // unlock    
        L := 0
        return y 
	\end{lstlisting}
\end{minipage}



Since enforcing serializability at runtime is impractical, many real-world systems use weaker consistency guarantees (see Section~\ref{subsec:related:notions-of-serializability}) like \textit{conflict serializability}, which considers only read/write patterns rather than full program semantics. The PL community has extensively studied static analysis for concurrent programs, including serializability checking. However, existing approaches have limitations: they typically either search for serializability \textit{violations} or require strong assumptions like bounded threads or known linearization points.
Moreover, many tools target specific concurrent data structures rather than general programs.
%
On the theoretical side, Bouajjani et al.~\cite{BoEmEnHa13} proved that serializability is decidable for unbounded threads (as a special case of bounded-barrier linearizability).


We bridge the gap between theory and practice by presenting an end-to-end tool that verifies serializability for arbitrary transactional programs.
To our knowledge, this is the first \emph{implemented} decision procedure that: (i) \textit{proves} serializability for unbounded executions; (ii) generates \textit{inductive proof certificates}; and (iii) handles complex programs from \textit{software defined networks} (SDN).
While the theoretical decidability has been established~\cite{BoEmEnHa13}, no prior implementation exists that can automatically generate correctness proofs for unbounded concurrent systems.
%
Our decision procedure builds on Bouajjani et al.'s reduction from serializability to Petri net reachability~\cite{BoEmEnHa13}. However, since Petri net reachability is Ackermann-complete~\cite{CzWo22}, a naive implementation fails even on simple programs. We developed several optimizations to make the approach practical. 
Our optimizations include Petri Net pruning, semilinear set compression, and additional manipulations with Presburger formulas.
These optimizations reduce the search space by orders of magnitude.
%
We formalize serializability using \textit{network systems} (NS) --- abstract concurrent programs where users send \textit{requests} that manipulate local and shared variables before returning \textit{responses}. This abstraction naturally models software-defined networks.
We evaluated our approach on dozens of programs featuring loops, branching, locks, and nondeterminism. Our benchmarks include SDN-inspired examples like stateful firewalls, BGP routing, and online shopping systems.


This work represents an important step toward practical verification of concurrent programs.
Beyond detecting serializability violations, our tool generates formal proof certificates when programs are serializable.
We note that while our approach is sound (never incorrectly claims serializability), the underlying SMPT Petri Net tool may time out on complex instances, limiting completeness in practice (which is unavoidable for any Petri Net tool, given the Ackermann-completeness of the problem).
Our tool, benchmarks, and experiments are available as an anonymous artifact~\cite{ArtifactRepository} and will be permanently hosted with the paperâ€™s final version.

The paper is organized as follows. Section~\ref{sec:tour} presents examples illustrating the complexity of serializability. Section~\ref{sec:problem-definition} formally defines network systems. Section~\ref{sec:formal-results} describes our decision procedure and optimizations. Sections~\ref{sec:implementation} and~\ref{sec:evaluation} present our implementation and evaluation. 
Related work is covered in Sec.~\ref{sec:related-work}, and we conclude in Sec.~\ref{sec:discussion}.
%
There is also a technical appendix accompanying this paper.

%\newpage




