\section{Discussion}
\label{sec:discussion}

\subsection{Conclusion}

To the best of our knowledge, ours is the first 
tool capable of verifying serializability in unbounded domains.
%
While these contributions represent significant advances, to our knowledge, our 
work is the first to:
(i) Decide serializability universally --- \textit{considering all executions} 
purely through program semantics and final states, independent of read/write 
conflicts; 
(ii) Support \textit{unbounded} transaction systems; and
(iii) Provide a complete end-to-end implementation.

\todo{Limitations?}
Examples we cannot solve, future work that would help
To conclude..


\subsection{Future Work}
Next..

We plan to use polyhedral reductions~\cite{AmBeDa21} that are structural reduction~\cite{Be87,BeLeDa20} of the form $(N_1, m_1) \vartriangleright_E (N_2, m_2)$, where $(N_1, m_1)$ is the Petri net we want to analyze, $(N_2, m_2)$ is a reduced version of this net (easier to model check), and $E$ is a Presburger formula that permits to reconstruct of the state space of $N_1$ from that of $N_2$. We plan to leverage this mechanism to trace back certificates obtained on the reduced net $N_2$ to the original net $N_1$, that would be the only kind of structural reduction for which such operation is possible.

\todo{Different notions of serializability}
\begin{itemize}
    \item \todo{Current notion: clients independently submit a request and get a response, and later they all get together and see if what they got was serializable}
    \item \todo{Stronger: clients are not independent, or sequentially execute some parts. General: we have some happens-before on the requests/responses}
    \item \todo{Weaker: the clients cannot communicate with each other afterwards to determine whether what they got was serializable, or they can only communicate in a limited way}
    \item \todo{Infinite / unbounded executions}
\end{itemize}