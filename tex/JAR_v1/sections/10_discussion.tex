

\section{Discussion}
\label{sec:discussion}

%\subsection{Conclusion}


%




\subsection{Limitations}
%\smallskip
%\noindent
%\textbf{Limitations.}
Our approach advances the state of the art in the important task of verifying unbounded serializability. However, several limitations still remain.
First, the \texttt{Ackermann}-completeness of Petri net reachability~\cite{CzWo22,Le22} can cause time-outs. %despite optimizations.
Second, we currently build on \texttt{SMPT}~\cite{AmDa23}, which is incomplete and can fail to find existing proofs.
Third, our network system abstraction is currently restricted to a simple request/response pattern and cannot capture more complex interactions, such as callbacks, streaming, or partial responses.
%Fourth, while we can verify programs with nondeterministic choice operators, we cannot handle programs with unbounded data domains or complex data structures beyond integer variables.
%
Finally, \toolname{} targets programs with finite reachable state: each request must be restricted to finite (reachable) local state and the program must induce finite (reachable) global state, though with unlimited requests. Hence, applying \toolname{} to real-world systems requires that the systems generate only a finite \textit{reachable} state space, otherwise, the network system is intractable.
%
This setting is similar to the one assumed by probabilistic model checkers such as \texttt{STORM}~\cite{DeJuKaVo17} and \texttt{PRISM}~\cite{KwNoPa02}.
%
%
%These limitations suggest important directions for future research.

\subsection{Future Work}
%\smallskip
%\noindent
\textbf{Additional optimizations.}
To further improve scalability, we are adapting \textit{polyhedral reductions}~\cite{AmBeDa21,amat2022polyhedral}, a structural reduction~\cite{Be87,BeLeDa20} $(N_1, m_1) \vartriangleright_E (N_2, m_2)$ where $N_2$ is a simpler Petri net and $E$ allows reconstructing the state space of $N_1$. If successful, this could allow verifying the reduced net $N_2$, and then lifting the proofs back to the original net $N_1$.
%
Furthermore, we believe an additional optimization avenue lies in \textit{over-approximating} the state space to decide serializability faster. In this context, our current approach already leverages this concept in the underlying model checker, which leverages the \textit{state equation} abstraction~\cite{Mu77}. We expect further approximation-based techniques to improve scalability gains even more.
%
Finally, additional optimizations involve  steps to short-circuit the algorithmic pipeline of our decision procedure. For example, we currently generate the reachability query $\mathcal{F}$ by: (i) using Kleene’s theorem to translate the serial NFA into a regular expression; (ii) using Parikh’s construction to translate the regular expression into a semilinear set; and then (iii) complementing this resulting semilinear set.
%
However, there are methods (for example, by Verma et al.~\cite{VeSeSc05}) that can \textit{directly} compute the automaton's Parikh image. Although the construction of this approach is linear in size, we have not adopted it because is heavily relies on Boolean logic, which we found to be handled poorly by the standard integer set library (\texttt{ISL}).
%
 
 
\medskip
\noindent
\textbf{Proof assistants.}
%
Another next step we plan is formalizing  the certificate checking procedure in a proof assistant (such as \texttt{Rocq}~\cite{Rocq}). This extension would entail (i) developing a novel verifier for the Petri net invariants that we use; and also (ii) proving theorems connecting serializability to invariant validity.
%
This would likely also require highly non-trivial steps, e.g., extending existing tactics such as \texttt{LIA} (Linear Integer Arithmetic), as it currently does not support full Presburger arithmetic --- an important requirement of our underlying logic.

 
%\todo{fix}
%\medskip
%\noindent
%\textbf{Complex communication settings.}
%%
%within the SDN domain, we plan to \textit{extend our framework to richer communication patterns}, beyond the current independent-client model. These include inter-client communication ---
%which requires 
%broadening our framework to afford distributed-system guarantees.

%
%Moreover, our support for arithmetic operations enables modeling commutative updates, covering a subset of PCM-style workloads.
%
%or Lamport’s \textit{happens-before}~\cite{La78}, while weaker ones restrict post-response communication or allow only summaries. Addressing these 

%decentralized or streaming certification under communication constraints, 

%\todo{old}
%
%\paragraph{Scalability.}
%
%Our evaluation shows that some benchmarks still time out.
%To improve \textit{scalability}, we are developing both theory and implementation of \textit{polyhedral reductions}~\cite{AmBeDa21} --- that are structural reductions~\cite{Be87,BeLeDa20} of the form $(N_1, m_1) \vartriangleright_E (N_2, m_2)$ where $N_2$ is a simpler Petri Net and $E$ is a formula enabling reconstruction of $N_1$'s state space from $N_2$'s. This would let us verify the reduced net and lift proofs back to the original net.
%
%\guy{Nicolas are you sure about the next sentence? Do you have an explanation or a "negative proof"?}
%
%Furthermore, we note that polyhedral reductions are the only type of structural reduction for which such a conversion is possible.
%
%We are developing both theory and implementation for this extension.
%
%\todo{Limitations?}
%Examples we cannot solve, future work that would help
%To conclude..
%
%
%
%In another axis, we aim to \textit{extend our framework to more diverse communication patterns.}
%\paragraph{Extensions to diverse communication models.}
%Currently, clients act independently: each issues a request, receives a response, then verification is centralized. Stronger models allow inter-client communication or partial orderings (Lamport’s \textit{happens-before}~\cite{La78}); weaker ones forbid post-response communication or permit only limited summaries. Addressing such settings will require decentralized certification or streaming proofs under communication constraints. Extending our framework along these axes would capture a broader class of practical distributed-system guarantees.


%\paragraph{Extensions to diverse communication models.}
%
%Our current framework assumes that clients act independently --- each submits a request, receives a response, and only afterward collaborates to verify (in a centralized manner) whether the combined outcomes are serializable. However, in a stronger model, clients may communicate during execution or enforce partial ordering of their interactions. More generally, this can be formalized via Lamport’s \textit{happens‐before} relation over request/response pairs~\cite{La78}. 
%%
%In contrast, a weaker model disallows communication --- in which case clients either cannot communicate after receiving responses or may only share limited summaries. Jointly deciding serializability in this setting will require decentralized certification techniques or streaming proofs that respect tight communication constraints. 
%%
%By extending our theory and tool along these two axes, we aim to cover a broad spectrum of practical distributed‐system guarantees, that are more complex and match broader, real-world scenarios.

%
%
%
%\todo{Different notions of serializability}
%\begin{itemize}
%    \item \todo{Current notion: clients independently submit a request and get a response, and later they all get together and see if what they got was serializable}
%    \item \todo{Stronger: clients are not independent, or sequentially execute some parts. General: we have some happens-before on the requests/responses}
%    \item \todo{Weaker: the clients cannot communicate with each other afterwards to determine whether what they got was serializable, or they can only communicate in a limited way}
%    \item \todo{Infinite / unbounded executions}
%\end{itemize}



\subsection{Applicability to Real-World Programs}
Due to limited switch memory and bounded-buffers on end-hosts, various real-world SDN programs satisfy our finite-reachable-state requirement. Furthermore, we anticipate that by using the following high-level mappings, \texttt{P4} programs~\cite{BoDaGiIzMcReScTaVaVaWa14} can be translated to equivalent \toolname{} code:
(i) packets correspond to requests, (ii) registers on switches correspond to global variables, (iii) header fields of packets correspond to local (per-request) variables, and (iv) forwarding packets corresponds to yielding. 
%
This natural translation also motivated us to evaluate our toolchain on models of SDN programs, such as \textit{stateful firewalls}~\cite{KiLiZhKiLeSeSe20,HoLaArReWa22}.
%
Moreover, we view our framework to be applicable beyond the SDN domain.
%
More concretely, our network system model captures distributed state together with message-passing/RPC-style concurrency, which maps naturally onto database transactions. As an illustration, consider our \textit{snapshot-monitoring benchmark} (see \Cref{sec:tour}). 



\subsection{Conclusion}
%\smallskip
%\noindent
%\textbf{Conclusion.}
%We present the first end-to-end framework that automatically verifies serializability for unbounded concurrent systems and generates proof certificates thereof.
%Our approach bridges theory and practice, with the following key contributions:
We introduce the first end-to-end framework capable of automatically verifying serializability for unbounded concurrent systems and generating corresponding proof certificates. Our approach bridges the gap between theory and practice through the following key contributions:
% by implementing Bouajjani et al.'s decision procedure with crucial optimizations that make it practical.
%
%Key contributions include: 
(1) formalizing the network system abstraction for concurrent systems, (2) implementing a full-blown decision procedure with proof certification, (3) reducing the space and time complexity significantly by adding multiple optimizations, and (4) extensively evaluating our approach on benchmarks inspired by real-world systems.
%

