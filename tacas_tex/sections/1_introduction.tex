\section{Introduction}
\label{sec:introduction}

Serializability—equivalence of every concurrent execution to some serial ordering—is a core correctness criterion for databases and SDNs~\cite{KrRaVePaRoAzUh14,XiWeFoNiXi15}. Violations cause subtle anomalies (e.g., lost updates, routing loops).
For a fixed number of requests one can enumerate interleavings, but in general the problem is undecidable; existing methods thus rely on runtime checks or incomplete bounded model checking~\cite{WaSt06a,WaSt06b,FlFrYi08,FaMa08,SiMaWaGu11a,SiMaWaGu11b,Pa79,AlMcPe96,BiEn19}.

Bouajjani et al.~\cite{BoEmEnHa13} proved decidability for programs with bounded state—even under \emph{unbounded} requests and \emph{unbounded} steps. We make this result practical: the first end-to-end decision procedure that either proves serializability (with a certificate) or finds a non-serializing execution (with a counterexample).
% 
We illustrate the problem by example:

% examples in Listings~\ref{lst:MotivatingExample1Ser},~\ref{lst:MotivatingExample2NonSer}, and ~\ref{lst:MotivatingExample3Ser}, written in our modeling language called \toolname.

\noindent
\begin{minipage}[t]{0.55\textwidth}
	\begin{minipage}[t]{\textwidth}
		\begin{lstlisting}[caption={Without yielding (serializable)},
			label={lst:MotivatingExample1Ser}]
  // request handler           
  request main: 
      X := 1 // X is global
      y := X // y is local
      X := 0
      return y 
		\end{lstlisting}
	\end{minipage}
	\vspace{1em}
	\begin{minipage}[t]{\textwidth}
		\begin{lstlisting}[caption={With yielding (not serializable)},
			label={lst:MotivatingExample2NonSer}]
  request main: 
      X := 1 
      yield // another request
      y := X // can read 0!
      X := 0
      return y 	
		\end{lstlisting}
	\end{minipage}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.35\textwidth}
	\begin{lstlisting}[caption={With yielding and a spin-lock (serializable)},
		label={lst:MotivatingExample3Ser}]
  request main: 
      // lock
      while (L == 1): 
          yield
      L := 1 

      X := 1
      yield
      y := X 
      X := 0

      // unlock    
      L := 0
      return y 
	\end{lstlisting}
\end{minipage}

These examples are written in our modeling language called \toolname.
A \toolname{} program has a set of named \textbf{request handlers} (one handler, \texttt{main}, in the examples) that are arbitrarily invoked concurrently by the external environment.
Each incoming request processes its request handler's body until it returns a value as its \textbf{response}. Concurrency is managed by the \(\yieldkw\)
 statement, which pauses the current request and gives other requests a chance to run. \toolname{} programs have uppercase \textbf{global shared variables} (\texttt{X} in the examples) and lowercase \textbf{request-local variables} (\texttt{y} in the examples).
%
%
%
The first program (Listing~\ref{lst:MotivatingExample1Ser}) is clearly serializable because there are no yields, and hence, no interleavings: each \texttt{main} request returns 1.
In the second program (Listing~\ref{lst:MotivatingExample2NonSer}), \texttt{yield} enables interleavings, and the program is \emph{not} serializable. With two concurrent requests, one can read \texttt{X=0} while the other returns 1, yielding the multiset \{(\texttt{main},0), (\texttt{main},1)\}, which no serial execution can produce.
Of course, having \texttt{yield}s does not guarantee that an execution is necessarily not serializable, as observed in the third snippet (Listing~\ref{lst:MotivatingExample3Ser}). This program uses an additional lock variable (\texttt{L}), which guarantees that even if an interleaving occurs, the program is semantically equivalent to the first one.
%
These examples demonstrate that reasoning about serializability can be complex even for very simple programs with few requests running concurrently.
%
For a tour of additional examples, we refer the reader to Appendix~\ref{appendix:tour}.
%\vspace{-.5em}

\smallskip
\noindent
\textbf{Problem Definition.}
An \textbf{observable execution} is a multiset of (request, response) pairs; the program’s \textbf{observable behavior} is the set of all such multisets over concurrent runs. A \toolname{} program is \textbf{serializable} if every observable execution is achievable serially (i.e., removing all \texttt{yield}s does not change semantics).

%\vspace{-.5em}
\smallskip
\noindent
\textbf{Challenges.}
Our approach builds on Bouajjani et al.’s reduction to Petri-net reachability~\cite{BoEmEnHa13}, which is \texttt{Ackermann}-complete~\cite{CzWo22}; naive implementations do not scale.

%\vspace{-.5em}
\smallskip
\noindent
\textbf{Our Approach.}
We introduce \textit{network systems} (NS): abstract programs where requests manipulate local and shared state and return responses. \toolname{} compiles programs to NS, reduces serializability to Petri-net reachability, and reasons via semilinear/Presburger analysis. Counterexamples are validated by simulation; proofs are checked as inductive invariants. To scale, we employ Petri-net pruning and semilinear-set optimizations, reducing the search space by orders of magnitude in practice. We evaluate on programs with loops, branching, locks, and nondeterminism, including SDN-inspired examples (firewalls, BGP, shopping).


\smallskip
\noindent
\textbf{Contributions:}
\toolname{} language and the NS abstraction (\Cref{sec:problem-definition}),
decision procedure with certificates and key optimizations (\Cref{sec:formal-results}), and
implementation and evaluation on diverse benchmarks (\Cref{sec:implementation},\Cref{sec:evaluation}, artifact~\cite{ArtifactRepository}).
